# **二叉树**



左子右兄弟表示法

### 静态二叉链表定义

```c++
struct Node
{
    int data;
    int le;
    int ri;
}node[N];
```

### 结点动态生成

```c++
int index = 0;
int newNode(int x)
{
    node[index].data = x;
    node[index].le = -1;
    node[index].ri = -1;
    return index ++;
}
```

### 查找并替换

```c++
void search(int root, int x, int newdata)
{
    //当根节点为空
    if(root == -1)
        return;
    
    //数据刚好等于 x，将该位置的数据替换成 newdata
    if(node[root].data == x)
        node[root].data = newdata;
    
    search(node[root].le, x, newdata); //往左子树查找
    search(node[root].ri, x, newdata); //往右子树查找
}
```

### 插入

```c++
void insert(int &root, int x)
{
    if(root == -1)
    {
        root = newNode(x);
        return ;
    }
    
    insert(node[root].le, x);
    insert(node[root].ri, x);
}
```

### 建立

```c++
int Create(int data[], int n)
{
    int root = -1;
    for(int i = 0; i < n; i ++)
    {
        insert(root, data[i]);
    }

    return root;
}
```

### 先序遍历(前序遍历) --> 根左右

```c++
void preorder(int root)
{
    if(root == -1)
        return ;
    
    //输出根节点
    cout << node[root].data << endl;
    preorder(node[root].le); //遍历左子树
    preorder(node[root].ri); //遍历右子树
}
```

### 中序遍历 --> 左根右

```c++
void inorder(int root)
{
    if(root == -1)
        return ;
    
    inorder(node[root].le);
    cout << node[root].data;
    inorder(node[root].ri);
}
```

### 后序遍历 --> 左右根

```c++
void postorder(int root)
{
    if(root == -1)
        return ;
    
    postorder(node[root].le);
    postorder(node[root].ri);
    cout << node[root].data << endl;
}
```

### 层次遍历 --> BFS宽度优先搜索

```c++
void LayerOrder(int root)
{
    queue<int> q;
    q.push(root);

    while(q.size())
    {
        int now = q.front();
        q.pop();
        cout << node[now].data;
        if(node[now].le != -1)
            q.push(node[now].le);
        if(node[now].ri != -1)
            q.push(node[now].ri);
    }
}
```

