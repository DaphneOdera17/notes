# 矩阵快速幂

$$
\left[                 
\begin{matrix}
1 & 1 \\
1 & 0 \\
\end{matrix}
\right]
\left[            
\begin{matrix}
F(n) \\
F(n - 1) \\
\end{matrix}
\right]
=
\left[            
\begin{matrix}
F(n) + F(n - 1) \\
F(n) \\
\end{matrix}
\right]
=
\left[            
\begin{matrix}
F(n + 1) \\
F(n) \\
\end{matrix}
\right]
$$

因此
$$
\left[                 
\begin{matrix}
F(n + 1) \\
F(n) \\
\end{matrix}
\right]
=
\left[                 
\begin{matrix}
1 & 1 \\
1 & 0 \\
\end{matrix}
\right]^n
\left[                 
\begin{matrix}
F(1) \\
F(0) \\
\end{matrix}
\right]
$$
令
$$
M =
\left[                 
\begin{matrix}
1 & 1 \\
1 & 0 \\
\end{matrix}
\right]
$$


```c++
typedef long long ll;

const int MOD = 1e9 + 7;

struct matrix
{
    ll c[101][101];
    //声明一个矩阵初始化变量
    //只要声明一个矩阵，就将 c 里面的数全部初始化为 0 
    matrix(){memset(c, 0, sizeof c);}
}A, res;

ll n, k;

//矩阵乘法
matrix operator *(matrix &x, matrix &y)
{
    matrix t;//临时矩阵
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            for(int k = 1; k <= n; k ++)
                t.c[i][j] = (t.c[i][j] + x.c[i][k] * y.c[k][j]) % MOD;
    return t;
}

void quickpow(ll k) //传入指数 k
{
    for(int i = 1; i <= n; i ++)
        res.c[i][i] = 1; //单位矩阵
    
    while(k)
    {
        if(k & 1)
            res = res * A;
        A = A * A;
        k >>= 1;
    }
}
```

