**计算机系统都是状态机**

一个简单的计算机系统：程序直接在 CPU 上运行(无操作系统)
	![image.png](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20240331002043.png)
这三个抽象层次(程序、指令集、CPU) 都可以用状态机来理解。

## 程序是个状态机：
### C 语言的组成：
	变量：计算的对象
	语句：计算的操作流程
	输入输出函数：让变量与外界交互
### C 程序的状态机模型
**状态集合**：S = {<V, PC>}
	**V** = {v1, v2, v3, ...} = 程序中所有变量的取值(包括全局变量和局部变量)
	**PC** = 程序计数器 = 当前执行的语句位置
**激励事件** E = {语句}
	执行 PC 指向的语句
**状态转移规则**：
	$next: S \times E -> S$
	语句的语义(semantics)
**初始状态** $S_0 = <V_0,~ main 函数的第一条语句 >$
```c
/* 1 **/ int main() {
/* 2 **/	int x = 1;
/* 3 **/	int y = 2;
/* 4 **/	int z = x + y;
/* 5 **/	printf("z = %d\n", z);
/* 6 **/	return 0;
/* 7 **/ }
```
对于的状态转移
```c
S = <x, y, z, PC>
S0 = <?, ?, ?, 2> // '?' 表示未初始化
S0 = <1, ?, ?, 3>
S0 = <1, 2, ?, 4>
S0 = <1, 2, 3, 5>
S0 = <1, 2, 3, 6> // 输出 "z = 3"
S0 = <1, 2, 3, 结束> 
```

### C 程序真的是从 $main()$ 第一条语句开始执行吗？
理解程序的动态行为 -> trace 工具
```shell
gcc a.c
strace ./a.out
```

发现退出程序后还有一个 $exit\_group()$ 
程序并不是在 $return~0$ 之后结束，它还会执行一些额外的操作。


