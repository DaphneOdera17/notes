[TOC]

对于 $[left, right]$

```c++
int l = 0, r = n - 1;
while(l <= r)
{
	int mid = l + (r - l) >> 1;
    if(a[mid] == target)
        return target;
   	else if(a[i] > target)
        r = mid - 1;
   	else
        l = mid + 1;
}
```

对于 $[left, right)$

```c++
int l = 0, r = n;
while(l < r)
{
	int mid = l + (r - l) >> 1;
    if(a[mid] == target)
        return target;
   	else if(a[i] > target)
        r = mid;
   	else
        l = mid + 1;
}
```



# **二分查找**

1. 确定一个区间，使得目标值一定在区间中
2. 找一个性质，满足：
   1. 性质具有二段性（一段满足，一段不满足）
   2. 答案是二段性的分界点

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231008002144823.png" style="zoom:50%;" />

第一类： ans 是红色区间的右端点

​	将 $[L,R]$ 分成 $[L,M - 1] ~~ [M,R]$

​	<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231008002424477.png" alt="image-20231008002424477" style="zoom:50%;" />

如果 M 是红色的，说明 ans 必然在 $[M,R]$ 

否则说明 ans 必然在 $[L,M-1]$

```c++
while(l < r)
{
	m = (l + r + 1) / 2;
	if m 红
		l = m;
	else
		r = m - 1;
}
```

因为整数有下取整，所以在算 mid 的时候要加 1 再除以 2



第二类： ans 是绿色区间的左端点

​	将 $[L,R]$ 分成 $[L,M] ~~ [M+1,R]$

​	如果 M 是绿色的，说明 ans 必然在 $[L,M]$ 

​	否则说明 ans 必然在 $[M+1,R]$

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231008003206476.png" alt="image-20231008003206476" style="zoom: 50%;" />

```c++
while(l < r)
{
	m = (l + r) / 2;
	if m 绿
		r = m;
	else
		l = m + 1;
}
```

### **整数二分步骤**

![image-20231008003847850](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231008003847850.png)



### **分巧克力**

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20230925111936.png" alt="蓝桥杯2017省AB ： 分巧克力" style="zoom:50%;" />

check() 函数是用来检测给定的正方形巧克力边长 x 是否能满足条件，即是否能够切出至少 k 块巧克力

可以切出的正方形巧克力的数量：

```
( h[i] / x ) * ( w[i] / x )
```

所以用一个 sum 来统计数量（记得要**初始化 0** 才能 用 += )

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int h[N], w[N];
int n, k;

bool check(int x)
{
    int sum = 0;
    //O (n)
    for(int i = 0; i < n; i++)
    {
        sum += ( h[i] / x ) * ( w[i] / x ); 
    }
    return sum >= k;
}

int main()
{
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i ++)
        scanf("%d%d", &h[i], &w[i]);
    //二分法
    int l = 1, r = 100000;
    
    // O (log N)
    while(l < r)
    {
        //因为 l = mid 所以 mid 里面 l + r 还要加 1
        int mid = (l + r + 1) / 2;
        if(check(mid))
        {
            l = mid;
            //如果切成 mid 大小的巧克力可以满足情况，往右边再搜索，看看能不能切成更大的， l 还可以取到
        }
        else r = mid - 1;
        //如果切成 mid 大小的巧克力不可以满足情况，往左边搜索，此时 r 不能再取 mid ，因为 mid 不能取到，所以 r = mid - 1;
    }
    printf("%d", l);
    return 0;
}
```

