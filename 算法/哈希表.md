# **哈希表**

## 散列

给出 $n$ 个数，再给出 $m$ 个数，判断这 $m$ 个数是否分别在这 $n$ 个数中出现过

**用空间换时间**，将输入的数作为数组的下标对数的性质进行统计

### 时间复杂度 $O(N+M)$

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

bool a[N];

int main()
{
    int n, m, x;
    cin >> n >> m;
    for(int i = 0; i < n; i ++)
    {
        cin >> x;
        a[x] = true;
    }

    for(int i = 0; i < m; i ++)
    {
        cin >> x;
        if(a[x] == true)
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }

    return 0;
}
```

若要判断出现的次数

讲 $bool$ 数组改为 $int$ 数组，每次输入 $x$，$a[x] ++$ 即可统计出现的次数

## 字符串哈希

若字符串均由大写字母 $A \sim Z$ 构成，则把它们视作 $0 \sim 25$，则转换成的整数最大为 $26^{len} - 1$，其中, $len$ 为字符串的长度
$$
H[i] = H[i - 1] \times 26 + index(str[i])
$$

```c++
int hashFunc(char S[], int len)
{
    int id = 0;
    for(int i = 0; i < len; i ++)
    {
        id = id * 26 + (S[i] - 'A');
    }
    return id;
}
```

若存在小写字母，则将 $a \sim z$ 视作 $26 \sim 51$

```c++
int hashFunc(char S[], int len)
{
    int id = 0;
    for(int i = 0; i < len; i ++)
    {
        if(S[i] >= 'A' && S[i] <= 'Z')
            id = id * 52 + (S[i] - 'A');
        else if(S[i] >= 'a' && S[i] <= 'z')
            id = id * 52 + (S[i] - 'A') + 26;
    }
    return id;
}
```

若存在数字

1. 可以按上述方法将增大进制数到 $62$
2. 如果能够保证在字符串的末尾是确切的数字，可以把前面字母部分的整数求出来，再将末尾的数字拼接上去

```c++
int hashFunc(char S[], int len)
{
    int id = 0;
    for(int i = 0; i < len - 1; i ++)
    {
        if(S[i] >= 'A' && S[i] <= 'Z')
            id = id * 26 + (S[i] - 'A');
    }

    id = id * 10 + (S[len - 1] - '0');

    return id;
}
```

输入 $N$ 个字符串(由恰好 $3$ 位大写字母构成)，再给出 $M$ 个查询字符串，问每个查询字符串在 $N$ 个字符串中出现的次数

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100;

char S[N][5], temp[5];

int hashTable[26 * 26 * 26 + 10];

//将字符串转换为整数
int hashFunc(char S[], int len)
{
    int id = 0;
    for(int i = 0; i < len; i ++)
        id = id * 26 + (S[i] - 'A');
    return id;
}

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 0; i < n; i ++)
    {
        cin >> S[i];
        //把字符串 S[i] 转换成整数
        int id = hashFunc(S[i], 3);
        //该字符串出现次数加 1
        hashTable[id] ++;
    } 
    for(int i = 0; i < m; i ++)
    {
        cin >> temp;
        int id = hashFunc(temp, 3);
        cout << hashTable[id] << endl;
    }

    return 0;
}
```

当字符串长度过长时，会导致产生的整数非常大，则需要对结果进行取模
$$
H[i] = (H[i - 1] \times 26 + index(str[i])) \% mod
$$
但是这样又可能产生冲突

如果把进制数设置成为一个 $10^7$ 级别的素数 $p$(例如 $1000007$)，同时把 $mod$ 设置为一个 $10^9$ 级别的素数(例如 $100000019$，冲突的概率就会变小
$$
H[i] = (H[i - 1] \times p + index(str[i])) \% mod
$$

$$
H[i] = H[i - 1] \times p + index(str[i])
$$

$$
H[i...j] = index(str[i] \times p^{j - i}) + index(str[i + 1] \times p^{j - i - 1}) + inde(str[j]) \times p^0
$$


$$
H[i...j] = (H[j] - H[i - 1] \times p^{j - i + 1}) \% mod
$$
为了保证结果的非负，应该先对结果取模，然后加上 $mod$ 后再次取模
$$
H[i...j] = ((H[j] - H[i - 1] \times p^{j - i + 1}) \% mod + mod) \% mod)
$$
