[TOC]

# **递归与递推**

## **递归实现指数型枚举**

![image-20231005124212854](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005124212854.png)

![image-20231005124641771](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005124641771.png)

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 15;

int n;
int st[N]; //记录每个位置当前的状态,0 表示还没考虑, 1 表示选，2 表示不选

void dfs(int u)
{
    if(u > n)
    {
        for(int i = 1; i <= n; i ++)
            if(st[i] == 1)
                cout << i << " ";
        cout << endl;
        return ;
    }

    st[u] = 2; //第一个分支不选
    dfs(u + 1);
    st[u] = 0;

    st[u] = 1; //第二个分支选
    dfs(u + 1);
    st[u] = 0;
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```

**记录路径**

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

const int N = 15;

int n;
int st[N]; //记录每个位置当前的状态,0 表示还没考虑, 1 表示选，2 表示不选
//int ways[1 << 15][16], cnt;
//2^15
vector<vector<int>> ways;

void dfs(int u)
{
    if(u > n)
    {
        vector<int> way;
        for(int i = 1; i <= n; i ++) //记录方案
            if(st[i] == 1)
                way.push_back(i);
                ways.push_back(way);
        return ;
    }

    st[u] = 2; //第一个分支不选
    dfs(u + 1);
    st[u] = 0;

    st[u] = 1; //第二个分支选
    dfs(u + 1);
    st[u] = 0;
}

int main()
{
    cin >> n;

    dfs(1);

    for(int i = 0; i < ways.size(); i ++)
    {
        for(int j = 0; j < ways[i].size(); j ++)
            printf("%d", ways[i][j]);
        puts("");
    }

    return 0;
}
```



## **递归实现排列型枚举**

顺序1：依次枚举每个数放到哪个位置

顺序2：依次枚举每个位置放哪个数

--> 递归搜索树

搜完一层往回走的时候要注意恢复现场

![image-20231005130231619](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005130231619.png)

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 20;

int st[N], path[N]; //st 记录数字是否被用过，path 用来保存序列
int n;

//dfs 深度优先遍历
void dfs(int u)
{
    if(u > n)
    {
        for(int i = 1; i <= n; i ++)
            cout << path[i] << " ";
        cout << endl;
        //return ; ?
    }
    
    for(int i = 1; i <= n; i ++)
    {
        if(!st[i]) //如果数字 i 未被用过
        {
            path[u] = i; //记录路径
            st[i] = 1; //标记为被用过
            dfs(u + 1);
            st[i] = 0; //恢复现场
        }
    }
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```

## **递归实现组合类型枚举**

![image-20231005134025496](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005134025496.png)

1. 构图	

   ![image-20231005134116194](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005134116194.png)

2. 树 --> dfs 参数 

   1. 位置上的数 way[n]
   2. 当前该枚举到哪个位置 u
   3. start 当前最小可以从哪个数枚举

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 30;

int n, m;
int way[N];

void dfs(int u, int start) //u 表示已经枚举到了哪个位置
{                          //start 表示当前最小可以从哪个数开始枚举 
    //当前正在选第 u 个数，即已经选了 u - 1 个数，然后要从 start 开始选，如果把 start 到 n 所有数都选上都不够 n, 那就无解，u - 1 + (n - start + 1) < m
    if(u + n - start < m)
        return; //优化
    if(u == m + 1)
    {
        for(int i = 1; i <= m; i ++)
            printf("%d ", way[i]);
        puts("");
        return ;
    }
    
    for(int i = start; i <= n; i ++)
    {
        way[u] = i;
        dfs(u + 1, i + 1);
        way[u] = 0; //恢复现场 
    }
}                           

int main()
{
    scanf("%d%d", &n, &m);

    dfs(1, 1);

    return 0;
}
```



## [蓝桥杯 2013 省 B] 带分数

### 题目描述

$100$ 可以表示为带分数的形式：$100 = 3 + \frac{69258}{714}$。

还可以表示为：$100 = 82 + \frac{3546}{197}$。

注意特征：带分数中，数字 $1$ ~ $9$ 分别出现且只出现一次（不包含 $0$）。

类似这样的带分数，$100$ 有 $11$ 种表示法。

### 输入格式

从标准输入读入一个正整数 $N(N<10^6)$。

### 输出格式

程序输出数字 $N$ 用数码 $1$ ~ $9$ 不重复不遗漏地组成带分数表示的全部种数。

注意：不要求输出每个表示，只统计有多少表示法！

### 样例 #1

### 样例输入 #1

```
100
```

### 样例输出 #1

```
11
```

### 样例 #2

### 样例输入 #2

```
105
```

### 样例输出 #2

```
6
```

### 提示

原题时限 3 秒, 64M。蓝桥杯 2013 年第四届省赛



#### 暴力做法

1. 枚举全排列

2. 枚举位数

3. 判断等式是否成立

   

#### **优化版**

$c \times n = c\times a + b$

1. 枚举 $a$
2. 枚举 $c$
3. 判断 $b$ 是否成立

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>

using namespace std;

const int N = 20;

bool st[N], backup[N];
int n, ans;

bool check(int a, int c)
{
    //先把 b 算出来
    int b = n * c - a * c;
    
    if(!c || !b || !a)
        return false;

    //
    memcpy(backup, st, sizeof st); //备份
    
    //判断 b 中的数是否会有用过的
    while(b)
    {
        int x = b % 10; //取个位
        b /= 10; //取完个位删除个位
        if(!x || backup[x])
            return false;
        backup[x] = true;
    }

    for(int i = 1; i <= 9; i ++) //判断每个数
        if(!backup[i])
            return false;
    
    return true;
}   

void dfs_c(int u, int a, int c)
{
    if(u >= 10) return;

    if(check(a, c))
        ans ++; //判断是否满足要求，满足的话答案 + 1
    
    for(int i = 1; i <= 9; i ++)
        if(!st[i]) //该数没有被用过
        {
            st[i] = true;
            dfs_c(u + 1, a, c * 10 + i); //加到 c 后面
            st[i] = false;
        }
}

//u 代表已经用了多少个数字
void dfs_a(int u, int a)
{
    if(a >= n)
        return;
    // a > 0
    if(a) dfs_c(u, a, 0); // 0 表示 c 的大小

    for(int i = 1; i <= 9; i ++)
        if(!st[i]) //这个数字没有被用过
        {
            st[i] = true;
            dfs_a(u + 1, a * 10 + i); // a * 10 + 1 相当于加上一个数字
                                      // 例如 1 变成 12
            st[i] = false; //恢复现场，回溯
        }
}

int main()
{
    cin >> n;
    
    dfs_a(0, 0);//第一个 0 表示已经用了多少个数字
                //第二个 0 表示当前的 a 是多少

    cout << ans << endl;

    return 0;
}
```



## **费解的开关**

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5×5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 $−1−1$。

#### 数据范围

$0<n≤5000≤500$

#### 输入样例：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

#### 输出样例：

```
3
2
-1
```

对于

```
11101
11101
11110
11111
11111
```

可以画图模拟

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005155705251.png" alt="image-20231005155705251" style="zoom: 25%;float:left" />

经过一次变化后

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005155814663.png" alt="image-20231005155814663" style="zoom: 25%;float:left" />

再经过一次变换

<img src="https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/image-20231005155847347.png" alt="image-20231005155847347" style="zoom:25%;float:left" />

1. 按的顺序可以任意

2. 每个格子最多只能按一次，按 2 次相当于没按

3. 每一行开关的操作完全被前一行灯的亮灭状态所决定

4. 判断最后一行，如果有灯灭着，说明无解

   

如何枚举第一行的操作

turn(x, y)

时间复杂度 $32 \times 25 \times 5 \times 500$

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 6;

char g[N][N], backup[N][N];
int n;
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};

//将 (x, y) 以及上下左右的灯都变成相反的颜色
void turn(int x, int y)
{
    for(int i = 0; i < 5; i ++)
    {
        int a = x + dx[i], b = y + dy[i];
        //如果在边界之外，跳过
        if(a < 0 || a >= 5 || b < 0 || b >= 5)
            continue;
        
        //异或运算，变成相反的数
        // 1 ^ 1 = 0, 0 ^ 1 = 1
        g[a][b] ^= 1;
    }
}

int main()
{
    cin >> n;
    while(n --)
    {
        for(int i = 0; i < 5; i ++)
            cin >> g[i]; //按行输入字符串

        int res = 10;

        //op 只是保存了第一行按开关的 32 种方式
        for(int op = 0; op < 32; op ++)
        {
            memcpy(backup, g, sizeof g);
            int step = 0;
            for(int i = 0; i < 5; i ++)
                //某位为一就代表选择按下这一位所在编号的开关
                if(op >> i & 1)
                {
                    step ++;
                    turn(0, i);
                }
            //通过第一行按完之后的状态去按第 2 3 4 行
            for(int i = 0; i < 4; i ++)
                for(int j = 0; j < 5; j ++)
                    //当前行某一位为 0
                    //就用它所在列的下一行去进行 turn 操作使它变成 1
                    if(g[i][j] == '0')
                    {
                        step ++;
                        turn(i + 1, j);
                    }
            //判断最后一行是否有灯没点亮
            //如果有说明方案不行
            bool dark = false;
            for(int i = 0; i < 5; i ++)
            {
                if(g[4][i] == '0')
                {
                    dark = true;
                    break;
                }
            }
            //取 32 种情况中能实现的方案中步数的最小值
            if(!dark)
                res = min(res, step);
            //备份数组    
            memcpy(g, backup, sizeof g);
        }

        if(res > 6)
            res = -1;
        
        cout << res << endl;
    }

    return 0;
}
```

> 枚举第一行的意义是：不需要在意第一行的灯是灭是暗，只需把第一行的按法枚举一遍，也就是我们说的 “操作”，每个位置都有两种选择，按(用1表示)或者不按(用0表示)，遍历这32种操作引发的情况，每一次再通过 res = min(res, step) ;把最小步数存一下，就能找到最优解





