RDT: reliable data transfer protocal
## 传输服务和协议
为运行在不同主机上的应用进程提供逻辑通信，提供进程到进程之间的服务。
传输协议运行在端系统。发送方将应用层的报文分成报文段，然后传递给网络层。接收方将报文段重组成报文，然后传递给应 用层。
传输层协议包括 TCP、UDP。
## 传输层和网络层的对比
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201201741.png)

传输层<font color="#c00000">无法加强</font><u>带宽、延迟</u>。

Ann 给 Bill 家寄信，一共 144 封信，而寄信有一定费用，所以 Ann 家老大把他们的信都收集起来 (复用) 放到邮箱，从 Ann 邮箱寄到 Bill 家邮箱相当于网络层这种服务，而 Bill 家收到之后，Bill 家老大负责将一大包信分发给老一、老二... (解复用)，此时类似于传输层。

```ad-quote
- 将端到端的网络层协议扩展到进程到进程的传输层协议称为复用和解复用。复用和解复用是所有计算机网络都需要的。
- 每个传输层段中都有一组信息，接收端主机传输层检查这些信息，将这些段直接传送给相应的 socket，这个过程称为**解复用** 。在源端主机中，从不同的socket中将数据片收集起来，加上头部信息封装成段，并且将段传送给网络层称为**复用**。
```

## Internet 传输层协议
- 可靠的、保序的传输：*TCP*
	- 多路复用、解复用
	- 拥塞控制 
	- 流量控制 
	- 建立连接
	- 字节流
- 不可靠、不保序的传输：*UDP* 
	- 多路复用、解复用 
	- 没有为尽力而为的 IP 服务添加更多的其它额外服务
	- 数据报
- 都不提供的服务： 
	- 延时保证 
	- 带宽保证

## 多路复用和解复用
在发送方主机多路复用: 从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装(该头部信息用于以后的解复用)。
在接收方主机多路解复用: 根据报文段的头部信息中的 IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。

### 多路解复用工作原理
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223719.png)

### 无连接 UDP 多路解复用
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223844.png)
当主机接收到UDP段时：检查UDP段中的目标端口号，将UDP段交给具备那个端口号的套接字。

```ad-note
如果多个UDP数据报具有相同的目标IP地址和目标端口号，即使它们的源IP地址或源端口号不同，这些数据报也会被传递到同一个目标UDP套接字上。
```

### 面向连接 TCP 的多路复用
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201224309.png)

## UDP
UDP：User Datagram Protocol \[RFC 768\] 用户数据报协议。
报文可能会丢失、乱序。
无连接: UDP发送端和接收端之间没有握手、每个UDP报文段都被独立地处理。UDP 被用于流媒体(丢失不敏感， 速率敏感、应用可控制传输速率)、DNS、SNMP

![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201222213.png)
### UDP 校验和
目标：检测在被传输报文段中的差错(如比特反转)

- 发送方：
	- 将报文段的内容视为16 比特的整数 
	- 校验和：报文段的加法和（1的补运算） 
	- 发送方将校验和放在 UDP的校验和字段
- 接收方：
	- 计算接收到的报文段的校验和 
	- 检查计算出的校验和与校验和字段的内容是否相等： 
		- 不相等–--检测到差错 
		- 相等–--没有检测到差错 ，但也许还是有差错->**残存错误**

例子：
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223540.png)

## RDT 可靠数据传输
### Rdt1.0：在可靠信道上的可靠数据传输
下层的信道是完全可靠的 
	没有比特出错 
	没有分组丢失 
发送方和接收方的 FSM (有限状态机) 
	发送方将数据发送到下层信道 
	接收方从下层信道接收数据
	
### Rdt2.0：具有比特差错的信道
下层信道可能会出错：将分组中的比特翻转。用校验和来检测比特差错。
确认(ACK)：接收方显式地告诉发送方分组已被正确接收 
否定确认(NAK): 接收方显式地告诉发送方分组发生了差错。发送方收到NAK后，发送方重传分组

如果ACK/NAK出错？ -> 发送方就不知道接收方到底要他重传还是不重传，此时要引入新的机制：序号。如果出错了，接收发不管发送方本来是 ACK 还是 NAK，都选择重发上一个分组，携带了序号，所以接收方可以知道这个序号。

处理重复： 
	发送方在每个分组中加入序号 
	如果ACK/NAK出错，发送方重传当前分组 
	接收方丢弃（不发给上层）重复分组 

Stop and wait 停等协议：发送方发送一个分组，然后等待接收方的应答

### Rdt2.1
发送方： 
	在分组中加入序列号。两个序列号（0，1）就足够了，一次只发送一个未经确认的分组 
	必须检测 ACK/NAK 是否出错（需要EDC） 
	状态数变成了两倍 
	必须记住当前分组的序列号为 0 还是 1
接收方： 
	必须检测接收到的分组是否是重复的 
	状态会指示希望接收到的分组的序号为0还是1

接收方并不知道发送方是否正确收到了其 ACK/NAK
#### 发送方处理出错的ACK/NAK
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205164902.png)
#### 接收方处理出错的ACK/NAK
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205165059.png)
#### Rdt2.1 的运行
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205182436.png)

### Rdt2.2: 无 NAK 的协议
只使用 ACK。接收方对最后正确接收的分组发 ACK，以替代 NAK，接收方必须显式地包含被正确接收分组的序号。
当收到重复的 ACK（如：再次收到 ack0）时，发送方与收到 NAK 采取相同的动作：重传当前分组。
#### rdt2.2 的运行
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205192320.png)

![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205193126.png)

### Rdt3.0：具有比特差错和分组丢失的信道
新的假设：
	下层信道可能会丢失分组（数据 或 ACK）

解决方法：
	需要发送方等待 ACK 一段合理的时间 
	发送端超时重传：如果到时没有收到 ACK -> 重传 

问题：
	如果分组（或ACK）只是被延迟了： 重传将会导致数据重复，但利用序列号已经可以处理这个问题 
	接收方必须指明被正确接收的序列号 

需要一个倒计数定时器
#### Rdt3.0 运行
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205194229.png)

![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205194329.png)

## 流水线协议
